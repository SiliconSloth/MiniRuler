package siliconsloth.miniruler.engine

import kotlin.reflect.KClass
import siliconsloth.miniruler.engine.builders.AtomicBuilder
import siliconsloth.miniruler.engine.builders.RuleBuilder
import siliconsloth.miniruler.engine.matching.CompleteMatch
import siliconsloth.miniruler.engine.stores.FactSet
import siliconsloth.miniruler.engine.stores.FactStore

class RuleEngine: FactUpdater<Any> {
    data class Update<T: Any>(val fact: T, val isInsert: Boolean, val maintainer: CompleteMatch? = null)

    data class QueuedMatch(val match: CompleteMatch, val ending: Boolean)

    /**
     * All the rules in the engine, grouped by the fact types they bind to.
     * Note that a rule can appear more than once, if it binds to multiple types.
     * Rules with no bindings are not stored, as they fire once and never do anything again.
     */
    val rules = mutableMapOf<KClass<*>, MutableList<Rule>>()
    
    /**
     * A fact store for each type of fact present in the engine.
     * FactSets are generated by default when new fact types are added, however users can
     * add stores of other types to improve search performance in conjunction with specialized filters.
     */
    val stores = mutableMapOf<KClass<*>, FactStore<out Any>>()

    /**
     * An optional list of rule matches maintaining each fact in the engine.
     * If all the matches maintaining a fact are ended, the fact is automatically deleted.
     * Facts with no maintainers in the first place are not affected.
     */
    val maintainers = mutableMapOf<Any, MutableList<CompleteMatch>>()

    // Some variables used by applyUpdates().
    var running = false
    val updateQueue = mutableMapOf<KClass<*>, MutableList<Update<*>>>()
    val matchQueue = mutableListOf<QueuedMatch>()

    inline fun <reified T: Any> addFactStore(store: FactStore<T>) {
        stores[T::class] = store
    }

    fun rule(definition: RuleBuilder.() -> Unit) {
        val rule = RuleBuilder(this).apply(definition).build()
        rule.bindings.forEach {
            rules.getOrPut(it.type) { mutableListOf() }.add(rule)
        }
    }

    fun applyUpdates(updates: Map<KClass<*>, List<Update<*>>>) {
        // All updates caused by the same firing cycle are merged into a single atomic update.
        // This helps maintain the illusion that the rules fire in parallel, as all updates they perform occur
        // simultaneously.
        updates.forEach { (type, ups) ->
            updateQueue.getOrPut(type) { mutableListOf() }.addAll(ups)
        }

        // If this update was triggered outside the engine, start a new update loop to apply the updates,
        // fire any rules that match the updated fact base, apply the updates triggered by those rules and so on.
        // If the loop was already running, meaning this update was triggered by a rule,
        // just queue the updates as above and leave the existing loop to handle it once the firing phase is over.
        if (!running) {
            running = true
            // Keep going until the rules stop triggering updates.
            while (updateQueue.isNotEmpty()) {
                // Remove any insertions of facts maintained by matches that have already ended.
                val batch = updateQueue.mapValues { it.value.filter { !(it.isInsert && it.maintainer?.ended ?: false) } }
                updateQueue.clear()

                // Update the fact stores.
                batch.forEach {
                    @Suppress("UNCHECKED_CAST")
                    applyUpdates(it.key as KClass<Any>, it.value as List<Update<Any>>)
                }

                // Update the match trees of every rule that binds with fact types updated by this update.
                // This process will cause new and ended matches to be added to matchQueue.
                val applicable = batch.keys.map { rules[it] ?: mutableListOf() }.flatten().distinct()
                applicable.forEach {
                    it.applyUpdates(batch)
                }

                // Execute all rule firings and endings caused by this update.
                matchQueue.forEach {
                    if (it.ending) {
                        it.match.end()
                    } else {
                        it.match.fire()
                    }
                }
                matchQueue.clear()
            }
            running = false
        }
    }

    /**
     * Apply a list of updates of one fact type to the appropriate fact store,
     * creating a new FactSet for that type if no store exists for it yet.
     */
    private fun <T: Any> applyUpdates(type: KClass<T>, updates: List<Update<T>>) {
        @Suppress("UNCHECKED_CAST")
        val store = stores.getOrPut(type) { FactSet<T>() } as FactStore<T>
        updates.forEach {
            if (it.isInsert) {
                store.insert(it.fact)
                if (it.maintainer != null) {
                    maintainers.getOrPut(it.fact) { mutableListOf() }.add(it.maintainer)
                }
            } else {
                store.delete(it.fact)
                maintainers.remove(it.fact)
            }
        }
    }

    fun queueMatch(match: CompleteMatch, ending: Boolean = false) {
        matchQueue.add(QueuedMatch(match, ending))
    }

    fun atomic(updates: AtomicBuilder.() -> Unit) =
        applyUpdates(AtomicBuilder(this).apply(updates).updates)

    override fun insert(fact: Any) = atomic {
        insert(fact)
    }

    override fun delete(fact: Any) = atomic {
        delete(fact)
    }

    override fun replace(old: Any, new: Any) = atomic {
        replace(old, new)
    }
}